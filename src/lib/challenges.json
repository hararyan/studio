
[
  {
    "id": 1,
    "title": "Two Sum Problem",
    "description": "The function should find two numbers that sum up to the target. The current implementation has a logical error.",
    "buggyCode": "function twoSum(nums, target) {\n  const numMap = {};\n  for (let i = 0; i <= nums.length; i++) { // Hint: Check the loop condition\n    const complement = target - nums[i];\n    if (numMap[complement] !== undefined) {\n      return [numMap[complement], i];\n    }\n    numMap[nums[i]] = i;\n  }\n  return [];\n}",
    "correctCode": "function twoSum(nums, target) {\n  const numMap = {};\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (numMap[complement] !== undefined) {\n      return [numMap[complement], i];\n    }\n    numMap[nums[i]] = i;\n  }\n  return [];\n}",
    "testCases": {
      "input": "nums = [2, 7, 11, 15], target = 9",
      "output": "[0, 1]"
    },
    "language": "javascript"
  },
  {
    "id": 2,
    "title": "Palindrome Checker",
    "description": "This function fails to correctly identify palindromes for strings with mixed casing. Modify it to be case-insensitive.",
    "buggyCode": "function isPalindrome(s) {\n  const cleanString = s.replace(/[^a-zA-Z0-9]/g, '');\n  const reversedString = cleanString.split('').reverse().join('');\n  // The comparison is case-sensitive!\n  return cleanString === reversedString;\n}",
    "correctCode": "function isPalindrome(s) {\n  const cleanString = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n  const reversedString = cleanString.split('').reverse().join('');\n  return cleanString === reversedString;\n}",
    "testCases": {
      "input": "'A man, a plan, a canal: Panama'",
      "output": "true"
    },
    "language": "javascript"
  },
  {
    "id": 3,
    "title": "Binary Search Off-by-One",
    "description": "A classic off-by-one error in the binary search algorithm is causing it to fail. Find and fix the boundary condition.",
    "buggyCode": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length; // Hint: What should the initial right boundary be?\n  while (left <= right) {\n    let mid = Math.floor(left + (right - left) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}",
    "correctCode": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left <= right) {\n    let mid = Math.floor(left + (right - left) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}",
    "testCases": {
      "input": "nums = [-1,0,3,5,9,12], target = 9",
      "output": "4"
    },
    "language": "javascript"
  },
  {
    "id": 4,
    "title": "Fibonacci Sequence Bug",
    "description": "The recursive function for the Fibonacci sequence is incorrect. It is not returning the right values for the sequence.",
    "buggyCode": "function fib(n) {\n  if (n <= 0) { // Hint: What is the base case for fib(1)?\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fib(n - 2) + fib(n - 3); // There's a bug in the recursion\n}",
    "correctCode": "function fib(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fib(n - 1) + fib(n - 2);\n}",
    "testCases": {
      "input": "n = 6",
      "output": "8"
    },
    "language": "javascript"
  }
]
